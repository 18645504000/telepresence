#!/Users/ark3/datawire/telepresence/virtualenv/bin/python3

import json
import os
import socket
from pathlib import Path
from socketserver import BaseRequestHandler, ThreadingUnixStreamServer
from ssl import SSLContext
from subprocess import CalledProcessError, Popen
from threading import Thread
from time import sleep
from traceback import format_exc
from typing import Any, Callable, Dict, List, Optional
from urllib.request import urlopen

from telepresence import TELEPRESENCE_BINARY
from telepresence.runner import Runner
from telepresence.utilities import str_command

__version__ = "dev-version"
__api__ = 1


class State:
    @classmethod
    def as_dict(cls):
        res = {}
        for key, value in cls.__dict__.items():
            if key.startswith("__"):
                continue
            try:
                json.dumps(value)
            except TypeError:
                continue
            res[key] = value
        return res

    network_ok = False
    cluster_ok = False
    bridge_ok = False

    cluster_info = None  # type: Optional[Dict[str, Any]]
    bridge_process = None  # type: Optional[Popen]
    interceptable = []  # type: List[Any]
    intercepts = []  # type: List[Any]


def render_fail(exc: CalledProcessError) -> str:
    res = f"Command failed:\n    {str_command(exc.cmd)}\n"
    res += f"  with exit code {exc.returncode}\n"
    if exc.stdout:
        res += f"  Output was:\n    {exc.stdout.strip()}\n"
    if exc.stderr:
        res += f"  Output was:\n    {exc.stderr.strip()}\n"
    return res


def loop_in_background(
    runner: Runner,
    name: str,
    function: Callable,
    more_args: Optional[List[Any]] = None,
    break_time=5,
) -> Thread:
    def loop():
        runner.write(f"Background thread {name} starting...")
        try:
            while True:
                function(runner, *(more_args if more_args is not None else []))
                sleep(break_time)
        finally:
            runner.write(f"FAIULRE: {name} thread ending!")

    th = Thread(target=loop, daemon=True)
    th.start()
    return th


def notify(runner: Runner, message: str, details="") -> None:
    runner.write(message)
    assert '"' not in message, message
    my_name = "(Playpen Daemon)"
    script = f'display notification "{{}}" with title "{message}"'
    if details:
        script += f" subtitle {my_name}"
        script = script.format(details)
        runner.write(details)
    else:
        script = script.format(my_name)
    if runner.platform == "darwin":
        runner.check_call(["osascript", "-e", script])


def update_maybe_notify(runner: Runner, attrib: str, curr_value: Any) -> bool:
    name = attrib.capitalize()
    attrib = attrib + "_ok"
    state_value = getattr(State, attrib)
    if curr_value != state_value:
        notify(runner, f"{name} {state_value} --> {curr_value}")
        setattr(State, attrib, curr_value)
        return True
    return False


def as_user(cluster=None):
    if cluster is None:
        cluster = State.cluster_info
    user = cluster["user"]
    env = cluster["env"]
    sudo_cmd = ["sudo", f"--user={user}", "--set-home", "--preserve-env"]
    return sudo_cmd, env


def run_as_user_sync(runner: Runner, args: List[str], cluster=None) -> None:
    sudo_cmd, env = as_user(cluster)
    runner.check_call(sudo_cmd + args, env=env)


def capture_as_user(runner: Runner, args: List[str], cluster=None) -> str:
    sudo_cmd, env = as_user(cluster)
    return runner.get_output(sudo_cmd + args, env=env)


def run_as_user_async(runner: Runner, args: List[str], cluster=None) -> Popen:
    sudo_cmd, env = as_user(cluster)
    name = f"{args[0]} as user"
    process = runner.launch(name, sudo_cmd + args, is_critical=False, env=env)
    return process


# teleproxy

# Replaced in main(...)
teleproxy = ""


def nuke_dns_cache(runner: Runner) -> None:
    if runner.platform == "darwin":
        try:
            runner.check_call(["killall", "-HUP", "mDNSResponder"])
        except CalledProcessError:
            pass


def launch_teleproxy_intercept(runner: Runner) -> None:
    nuke_dns_cache(runner)
    try:
        runner.check_call([teleproxy, "-mode", "intercept"])
    except CalledProcessError:
        pass


def check_teleproxy_intercept(runner: Runner) -> bool:
    try:
        with urlopen("http://teleproxy/api/tables/", timeout=2.0) as fd:
            fd.read()
        curr = True
    except OSError as exc:
        runner.write(f"Intercept check failed: {exc}")
        nuke_dns_cache(runner)
        curr = False
    update_maybe_notify(runner, "network", curr)
    return curr


def launch_teleproxy_bridge(runner: Runner):
    """Launch the bridge"""
    try:
        return run_as_user_async(runner, [teleproxy, "-mode", "bridge"])
    except CalledProcessError:
        pass


def check_teleproxy_bridge(runner: Runner) -> bool:
    """Verify connectivity via proxy"""
    if State.cluster_info is None:
        curr = False
    else:
        insecure_context = SSLContext()
        try:
            with urlopen(
                "https://kubernetes/api/",
                timeout=5.0,
                context=insecure_context,
            ) as fd:
                fd.read()
            curr = True
        except OSError as exc:
            runner.write(f"Bridge check failed: {exc}")
            curr = False
    update_maybe_notify(runner, "bridge", curr)
    return curr


def check_cluster(runner: Runner) -> bool:
    """Verify k8s cluster is okay"""
    if State.cluster_info is None:
        curr = False
    elif State.bridge_ok:
        curr = True
    else:
        kcheck = ["kubectl", "get", "pod", "ohai", "--ignore-not-found"]
        try:
            run_as_user_sync(runner, kcheck)
            curr = True
        except CalledProcessError:
            curr = False
    update_maybe_notify(runner, "cluster", curr)
    return curr


def perform_checks(runner: Runner) -> None:
    check_teleproxy_intercept(runner)
    check_teleproxy_bridge(runner)
    check_cluster(runner)


# Playpen Daemon socket server


class PlaypenServer(ThreadingUnixStreamServer):
    def server_activate(self):
        os.chmod(self.server_address, 0o777)
        super().server_activate()


class PlaypenRequestHandler(BaseRequestHandler):
    def setup(self):
        self.runner = self.server.runner  # type: Runner
        self.send_ok = True

    def send(self, line: str) -> None:
        if not self.send_ok:
            return

        message = (line.rstrip() + "\n").encode("utf8")
        try:
            self.request.sendall(message)
        except OSError as exc:
            self.runner.write(f"Request error: Send failed: {exc}")
            self.send_ok = False

    def fail(self, message: str) -> int:
        self.send(f"playpen: {message}")
        return 1

    def parse_request(self):
        try:
            in_file = self.request.makefile("r")
            req = json.load(in_file)
            in_file.close()
        except ValueError as exc:
            raise ValueError(f"Client JSON error: {exc}")

        try:
            client_api = req["api"]
            args = req["args"]
        except KeyError as exc:
            raise ValueError(f"Client failure (missing {exc.args[0]})")

        if client_api != __api__:
            self.version(req)
            raise ValueError(
                f"API mismatch: server v{__api__}, client v{client_api}"
            )

        if args:
            command = args[0]
        else:
            command = "status"

        try:
            req["method"] = getattr(self, command)
        except AttributeError:
            raise ValueError(f"unknown command: {command}")

        self.runner.write(f"Request: {command}")
        return req

    def call_method(self):
        try:
            req = self.parse_request()
        except ValueError as exc:
            message = str(exc)
            self.runner.write(f"Request failed: {message}")
            return self.fail(str(exc))
        return req["method"](req)

    def handle(self):
        try:
            code = self.call_method()
        except Exception as exc:
            self.runner.write(f"CRASH: {exc}")
            self.runner.write(format_exc())
            self.send(f"Internal server error: {exc}")
            code = 255
        self.send(f"-- exit {code}")

    def version(self, req) -> int:
        self.send(f"Playpen Daemon {__version__}")
        return 0

    def status(self, req) -> int:
        if not State.network_ok:
            self.send("Network overrides NOT established")
        if not State.cluster_info:
            self.send("Not connected")
            return 0
        if State.cluster_ok:
            self.send("Connected")
        else:
            self.send("Attempting to reconnect...")
        context = State.cluster_info["context"]
        server = State.cluster_info["server"]
        if State.bridge_ok:
            proxy = "ON (networking to the cluster is enabled)"
        else:
            proxy = "OFF (attempting to connect...)"
        self.send(
            f"  Context:       {context} ({server})\n"
            f"  Proxy:         {proxy}\n"
            f"  Interceptable: {len(State.interceptable)} deployments\n"
            f"  Intercepts:    ? total, {len(State.intercepts)} local\n"
        )
        return 0

    def connect(self, req) -> int:
        if State.cluster_info is not None:
            return self.fail("Already connected")
        if State.bridge_process is not None:
            return self.fail("Not ready: Trying to disconnect")
        if not State.network_ok:
            return self.fail("Not ready: Establishing network overrides")
        State.cluster_info = req
        if not check_cluster(self.runner):
            State.cluster_info = None
            return self.fail("Unable to talk to cluster")
        try:
            ctx = State.cluster_info["context"] = capture_as_user(
                self.runner, ["kubectl", "config", "current-context"]
            )
            srv = State.cluster_info["server"] = capture_as_user(
                self.runner, [
                    "kubectl", "config", "view", "--minify", "-o",
                    "jsonpath={.clusters[0].cluster.server}"
                ]
            )
        except CalledProcessError as exc:
            State.cluster_info = None
            self.send(render_fail(exc))
            return self.fail("Unable to talk to cluster")
        State.bridge_process = launch_teleproxy_bridge(self.runner)
        self.send(f"Connected to context {ctx} ({srv})")
        return 0

    def disconnect(self, req) -> int:
        assert self.runner is not None
        if State.cluster_info is None:
            return self.fail("Not connected")
        # FIXME: Disconnect all intercepts
        if State.bridge_process is not None:
            State.bridge_process.terminate()
            State.bridge_process = None
        State.cluster_info = None
        check_cluster(self.runner)
        self.send("Disconnected")
        return 0


def main():
    if os.geteuid() != 0:
        exit("Playpen Daemon must run as root.")

    sockname = "/var/run/playpen.socket"
    test_sock = socket.socket(socket.AF_UNIX)
    try:
        test_sock.connect(sockname)
    except FileNotFoundError:
        pass
    else:
        exit("It appears that Playpen Daemon is already running.")

    runner = Runner("-", None, True)
    runner.add_cleanup("remove socket", os.unlink, sockname)
    PlaypenRequestHandler.runner = runner

    global teleproxy
    my_dir = Path(TELEPRESENCE_BINARY).parent
    proxy_name = f"pp-teleproxy-{runner.platform}-amd64"
    teleproxy = str(my_dir / proxy_name)
    runner.require([teleproxy], "Perhaps try reinstalling Playpen")

    with runner.cleanup_handling():
        # Intercept runs all the time
        loop_in_background(
            runner, "Teleproxy Intercept", launch_teleproxy_intercept
        )
        # Status checks (and notifications) run all the time
        loop_in_background(runner, "Periodic Status Checks", perform_checks)

        try:
            with PlaypenServer(sockname, PlaypenRequestHandler) as server:
                server.runner = runner
                runner.show("Playpen Daemon starting...")
                server.serve_forever()
        except KeyboardInterrupt:
            runner.show("Interrupted.")


if __name__ == "__main__":
    main()
