#!/Users/ark3/datawire/telepresence/virtualenv/bin/python3

import argparse
import json
import os
import socket
import unicodedata
from pathlib import Path
from signal import SIGTERM
from socketserver import BaseRequestHandler, ThreadingUnixStreamServer
from ssl import SSLContext
from subprocess import CalledProcessError, Popen
from threading import Thread
from time import sleep, strftime
from traceback import format_exc
from typing import Any, Callable, Dict, List, Optional
from urllib.request import urlopen

from telepresence import TELEPRESENCE_BINARY
from telepresence.runner import Runner
from telepresence.utilities import str_command

__version__ = "dev-version"
__api__ = 1


class State:
    @classmethod
    def as_dict(cls):
        res = {}
        for key, value in cls.__dict__.items():
            if key.startswith("__"):
                continue
            try:
                json.dumps(value)
            except TypeError:
                continue
            res[key] = value
        return res

    network_ok = False
    cluster_ok = False
    bridge_ok = False

    cluster_info = None  # type: Optional[Dict[str, Any]]
    bridge_process = None  # type: Optional[Popen]
    interceptable = []  # type: List[Any]
    intercepts = []  # type: List[Any]


def render_fail(exc: CalledProcessError) -> str:
    res = f"Command failed:\n    {str_command(exc.cmd)}\n"
    res += f"  with exit code {exc.returncode}\n"
    if exc.stdout:
        res += f"  Output was:\n    {exc.stdout.strip()}\n"
    if exc.stderr:
        res += f"  Output was:\n    {exc.stderr.strip()}\n"
    return res


def loop_in_background(
    runner: Runner,
    name: str,
    function: Callable,
    more_args: Optional[List[Any]] = None,
    break_time=5,
) -> Thread:
    def loop():
        runner.write(f"Background thread {name} starting...")
        try:
            while not runner.quitting:
                function(runner, *(more_args if more_args is not None else []))
                sleep(break_time)
        finally:
            runner.write(f"FAILURE: {name} thread ending!")

    th = Thread(target=loop, daemon=True)
    th.start()
    return th


def notify(runner: Runner, message: str) -> None:
    runner.write(message)
    assert '"' not in message, message
    message = message.replace("-->", unicodedata.lookup("RIGHTWARDS ARROW"))
    my_name = "(Playpen Daemon)"
    if runner.platform == "darwin":
        script = f'display notification "{my_name}" with title "{message}"'
        command = ["osascript", "-e", script]
    else:
        command = ["notify-send", "--app-name=Playpen", message, my_name]
    try:
        runner.check_call(command)
    except (CalledProcessError, OSError):
        pass  # Already logged by Runner library


def update_maybe_notify(runner: Runner, attrib: str, curr_value: Any) -> bool:
    name = attrib.capitalize()
    attrib = attrib + "_ok"
    state_value = getattr(State, attrib)
    if curr_value != state_value:
        notify(runner, f"{name} {state_value} --> {curr_value}")
        setattr(State, attrib, curr_value)
        return True
    return False


def as_user(cluster=None):
    if cluster is None:
        cluster = State.cluster_info
    user = cluster["user"]
    env = cluster["env"]
    sudo_cmd = ["sudo", f"--user={user}", "--set-home", "--preserve-env"]
    return sudo_cmd, env


def run_as_user_sync(runner: Runner, args: List[str], cluster=None) -> None:
    sudo_cmd, env = as_user(cluster)
    runner.check_call(sudo_cmd + args, env=env)


def capture_as_user(runner: Runner, args: List[str], cluster=None) -> str:
    sudo_cmd, env = as_user(cluster)
    return runner.get_output(sudo_cmd + args, env=env)


def run_as_user_async(runner: Runner, args: List[str], cluster=None) -> Popen:
    sudo_cmd, env = as_user(cluster)
    name = f"{args[0]} as user"
    process = runner.launch(name, sudo_cmd + args, is_critical=False, env=env)
    return process


def mark_log_time(runner: Runner) -> None:
    runner.write(strftime("Checkpoint %Y-%m-%d %H:%M:%S"))


# teleproxy

# Replaced in main(...)
teleproxy = ""


def nuke_dns_cache(runner: Runner) -> None:
    if runner.platform == "darwin":
        try:
            runner.check_call(["killall", "-HUP", "mDNSResponder"])
        except CalledProcessError:
            pass


def launch_teleproxy_intercept(runner: Runner) -> None:
    nuke_dns_cache(runner)
    try:
        runner.check_call([teleproxy, "-mode", "intercept"])
    except CalledProcessError:
        pass


def kill_teleproxy_intercept(runner: Runner) -> None:
    try:
        with urlopen("http://127.254.254.254/api/shutdown", timeout=2.0) as fd:
            fd.read()
        sleep(0.75)
    except OSError as exc:
        runner.write(f"Intercept kill failed: {exc}")


def check_teleproxy_intercept(runner: Runner) -> bool:
    try:
        with urlopen("http://teleproxy/api/tables/", timeout=2.0) as fd:
            fd.read()
        curr = True
    except OSError as exc:
        runner.write(f"Intercept check failed: {exc}")
        nuke_dns_cache(runner)
        curr = False
    update_maybe_notify(runner, "network", curr)
    return curr


def launch_teleproxy_bridge(runner: Runner):
    """Launch the bridge"""
    try:
        return run_as_user_async(runner, [teleproxy, "-mode", "bridge"])
    except CalledProcessError:
        pass


def check_teleproxy_bridge(runner: Runner) -> bool:
    """Verify connectivity via proxy"""
    if State.cluster_info is None:
        curr = False
    else:
        insecure_context = SSLContext()
        try:
            with urlopen(
                "https://kubernetes/api/",
                timeout=5.0,
                context=insecure_context,
            ) as fd:
                fd.read()
            curr = True
        except OSError as exc:
            runner.write(f"Bridge check failed: {exc}")
            curr = False
    update_maybe_notify(runner, "bridge", curr)
    return curr


def check_cluster(runner: Runner) -> bool:
    """Verify k8s cluster is okay"""
    if State.cluster_info is None:
        curr = False
    elif State.bridge_ok:
        curr = True
    else:
        kcheck = ["kubectl", "get", "pod", "ohai", "--ignore-not-found"]
        try:
            run_as_user_sync(runner, kcheck)
            curr = True
        except CalledProcessError:
            curr = False
    update_maybe_notify(runner, "cluster", curr)
    return curr


def disconnect_cluster(runner: Runner) -> None:
    """Disconnect from the cluster in an idempotent way"""
    # FIXME: Disconnect all intercepts
    if State.bridge_process is not None:
        State.bridge_process.terminate()
        State.bridge_process = None
    State.cluster_info = None
    check_cluster(runner)


def perform_checks(runner: Runner) -> None:
    check_teleproxy_intercept(runner)
    check_teleproxy_bridge(runner)
    check_cluster(runner)


# Playpen Daemon socket server


class PlaypenServer(ThreadingUnixStreamServer):
    def server_activate(self):
        os.chmod(self.server_address, 0o777)
        super().server_activate()


class ParserError(Exception):
    pass


class Parser(argparse.ArgumentParser):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._collected_output = ""

    def _print_message(self, message, file=None):
        if message:
            self._collected_output += message

    def exit(self, status=0, message=None):
        self._print_message(message)
        raise ParserError(self._collected_output)


class PlaypenRequestHandler(BaseRequestHandler):
    def setup(self):
        self.runner = self.server.runner  # type: Runner
        self.send_ok = True

    def send(self, line: str) -> None:
        if not self.send_ok:
            return

        message = (line.rstrip() + "\n").encode("utf8")
        try:
            self.request.sendall(message)
        except OSError as exc:
            self.runner.write(f"Request error: Send failed: {exc}")
            self.send_ok = False

    def fail(self, message: str) -> int:
        self.send(f"playpen: {message}")
        return 1

    def parse_client_args(self, args: List[str]) -> str:
        doc_url = "https://github.com/telepresenceio/telepresence/blob/playpen/readme-playpen.md"
        parser = Parser(prog="playpen", epilog=f"See also {doc_url}")
        subparsers = parser.add_subparsers(dest="command", metavar="COMMAND")
        sap = subparsers.add_parser
        _ = sap("version", help="Show client and server versions")
        _ = sap("quit", help="Have the server quit (for upgrades)")
        _ = sap("status", help="Show connectivity status")
        _ = sap("connect", help="Connect to a cluster")
        _ = sap("disconnect", help="Disconnect from the connected cluster")
        ns = parser.parse_args(args)
        if ns.command is None:
            ns.command = "status"
        return ns.command

    def parse_request(self):
        try:
            in_file = self.request.makefile("r")
            req = json.load(in_file)
            in_file.close()
        except ValueError as exc:
            raise ValueError(f"Client JSON error: {exc}")

        try:
            client_api = req["api"]
            args = req["args"]
        except KeyError as exc:
            raise ValueError(f"Client failure (missing {exc.args[0]})")

        if client_api != __api__:
            self.version(req)
            raise ValueError(
                f"API mismatch: server v{__api__}, client v{client_api}"
            )

        command = self.parse_client_args(args)

        try:
            req["method"] = getattr(self, command)
        except AttributeError:
            raise ValueError(f"unknown command: {command}")

        self.runner.write(f"Request: {command}")
        return req

    def call_method(self):
        try:
            req = self.parse_request()
        except ValueError as exc:
            self.runner.write(f"Request failed: {str(exc)}")
            return self.fail(str(exc))
        except ParserError as exc:
            return self.fail(str(exc))
        return req["method"](req)

    def handle(self):
        try:
            code = self.call_method()
        except Exception as exc:
            self.runner.write(f"CRASH: {exc}")
            self.runner.write(format_exc())
            self.send(f"Internal server error: {exc}")
            code = 255
        self.send(f"-- exit {code}")

    def version(self, req) -> int:
        self.send(f"Playpen Daemon v{__version__} (api v{__api__})")
        return 0

    def quit(self, req) -> int:
        self.send("Playpen Daemon quitting...")
        os.kill(os.getpid(), SIGTERM)
        return 0

    def status(self, req) -> int:
        if not State.network_ok:
            self.send("Network overrides NOT established")
        if not State.cluster_info:
            self.send("Not connected")
            return 0
        if State.cluster_ok:
            self.send("Connected")
        else:
            self.send("Attempting to reconnect...")
        context = State.cluster_info["context"]
        server = State.cluster_info["server"]
        if State.bridge_ok:
            proxy = "ON (networking to the cluster is enabled)"
        else:
            proxy = "OFF (attempting to connect...)"
        self.send(
            f"  Context:       {context} ({server})\n"
            f"  Proxy:         {proxy}\n"
            f"  Interceptable: {len(State.interceptable)} deployments\n"
            f"  Intercepts:    ? total, {len(State.intercepts)} local\n"
        )
        return 0

    def connect(self, req) -> int:
        if State.cluster_info is not None:
            return self.fail("Already connected")
        if State.bridge_process is not None:
            return self.fail("Not ready: Trying to disconnect")
        if not State.network_ok:
            return self.fail("Not ready: Establishing network overrides")
        State.cluster_info = req
        if not check_cluster(self.runner):
            State.cluster_info = None
            return self.fail("Unable to talk to cluster")
        try:
            ctx = State.cluster_info["context"] = capture_as_user(
                self.runner, ["kubectl", "config", "current-context"]
            )
            srv = State.cluster_info["server"] = capture_as_user(
                self.runner, [
                    "kubectl", "config", "view", "--minify", "-o",
                    "jsonpath={.clusters[0].cluster.server}"
                ]
            )
        except CalledProcessError as exc:
            State.cluster_info = None
            self.send(render_fail(exc))
            return self.fail("Unable to talk to cluster")
        State.bridge_process = launch_teleproxy_bridge(self.runner)
        self.send(f"Connected to context {ctx} ({srv})")
        return 0

    def disconnect(self, req) -> int:
        if State.cluster_info is None:
            return self.fail("Not connected")
        disconnect_cluster(self.runner)
        self.send("Disconnected")
        return 0


def main():
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument(
        "--version", action="version", version=f"Playpen Daemon {__version__}"
    )
    parser.parse_args()

    if os.geteuid() != 0:
        exit("Playpen Daemon must run as root.")

    sockname = "/var/run/playpen.socket"
    test_sock = socket.socket(socket.AF_UNIX)
    try:
        test_sock.connect(sockname)
    except FileNotFoundError:
        pass
    else:
        exit("It appears that Playpen Daemon is already running.")

    runner = Runner("/tmp/playpen.log", None, True)
    runner.add_cleanup("remove socket", os.unlink, sockname)
    runner.add_cleanup(
        "kill teleproxy intercept", kill_teleproxy_intercept, runner
    )
    runner.add_cleanup("disconnect from cluster", disconnect_cluster, runner)
    PlaypenRequestHandler.runner = runner

    global teleproxy
    my_dir = Path(TELEPRESENCE_BINARY).parent
    proxy_name = f"pp-teleproxy-{runner.platform}-amd64"
    teleproxy = str(my_dir / proxy_name)
    runner.require([teleproxy], "Perhaps try reinstalling Playpen")

    with runner.cleanup_handling():
        # Make the logs easier to scroll through
        loop_in_background(
            runner, "Logging checkpoints", mark_log_time, break_time=300
        )
        # Intercept runs all the time
        loop_in_background(
            runner, "Teleproxy Intercept", launch_teleproxy_intercept
        )
        # Status checks (and notifications) run all the time
        loop_in_background(runner, "Periodic Status Checks", perform_checks)

        try:
            with PlaypenServer(sockname, PlaypenRequestHandler) as server:
                server.runner = runner
                runner.show("Playpen Daemon starting...")
                server.serve_forever()
        except KeyboardInterrupt:
            runner.show("Interrupted.")


if __name__ == "__main__":
    main()
